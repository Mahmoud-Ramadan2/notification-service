spring.application.name=${SPRING_APPLICATION_NAME}

server.port=${SERVER_PORT}

# Eureka
eureka.client.serviceUrl.defaultZone=${EUREKA_CLIENT_SERVICEURL_DEFAULTZONE}
eureka.instance.preferIpAddress=${EUREKA_INSTANCE_PREFERIPADDRESS}

# Kafka config
spring.kafka.bootstrap-servers=${KAFKA_BOOTSTRAP_SERVERS}
spring.kafka.consumer.group-id=${KAFKA_CONSUMER_GROUP}
spring.kafka.consumer.auto-offset-reset=${KAFKA_CONSUMER_OFFSET}
spring.kafka.consumer.key-deserializer=${KAFKA_CONSUMER_KEY_DESERIALIZER}
spring.kafka.consumer.value-deserializer=${KAFKA_CONSUMER_VALUE_DESERIALIZER}
# ignore producer type headers entirely. That?s the key to avoid the ?failed to resolve class name
spring.kafka.consumer.properties.spring.json.use.type.headers=false
spring.kafka.consumer.properties.spring.json.value.default.type=com.mahmoud.appointmentsystem.notificationservice.kafka.eventsDTO.AppointmentEvent

# Ensures message durability by requiring acknowledgment from all replicas before considering a message committed.
spring.kafka.producer.acks=all
# retry on failure
spring.kafka.producer.retries=3
# Active profile
spring.profiles.active=${SPRING_PROFILES_ACTIVE}
